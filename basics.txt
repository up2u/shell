1: syntax: expr op1 operator op2 #space is required between number and operator
[maolijie@neptune ~]$ expr 5 + 2   
7 

2: integer(Number without decimal point)
  -eq -ne -lt -le -gt -ge 
  if test 5 -eq 6

3: string Comparisons
   string1  = string2
   string1 != string2
   string              string1 is NOT NULL or not defined
   -n string1          string1 is NOT NULL and does exist
   -z string1          string1 is NULL and does exist

4: file and directory
   -s file              Non empty file 
   -f file              Is File exist or normal file and not a directory
   -d dir               Is Directory exist and not a file
   -w file              Is writeable file
   -r file              Is read-only file
   -x file              Is file is executable
5: Logical Operators
   !                    NOT
   -a                   AND
   -o                   OR
6:
1) if condition
   then
   
   else
	   
   fi 

2):if condition
   then

   elif condition

   elif condition

   else

   fi
7:for var in list
  do
 
  done

8:while condition
  do
	  
  done 

9: case $vari in 
     pattern)
	           command
			   ;;
     pattern)
	           command
			   ;;
     *)
	           command
			   ;;
   esac
 
 10: positional parameters
 
  $#        Number of command line arguments
  $*        All of the positional parameters, seen as a single word
            "$*" must be quoted.
  $@        Same as $*, but each parameter is a quoted string
			that is, the parameters are passed on intact, 
			without interpretation or expansion.  This means, 
			among other things, that each parameter in the 
			argument list is seen as a separate word.
			"$@" should be quoted

  $-        Flags passed to script(using set)
            This was originally a ksh construct adopted into Bash

  $!        PID (process ID) of last job run in background

  $_        Special variable set to last argument of previous 
            command executed.

            example:
			#! /bin/bash
			
			echo $_           # /bin/bash

			du > /dev/null 
			echo $_           # du

			ls -al > /dev/null
			echo $_           # -al (last argument)

			:
			echo $_           # :

  $?    Exit status of a command
  $$    Process ID of the script itself.

###
  strings
1: string length
  ${#string}
  expr length $string
  expr "$string":'.*'
eg:
  string=abcdef
  echo `expr "$string" : '.*'`              # 6

2:length of matching substring at beginning of string
  expr match "$string" '$substring'
  expr "$string" : '$substring'
eg:
  stringZ=abcABC123ABCabc
  echo `expr match "$stringZ" 'abc[A-Z]*.2'` # 8
  echo `expr "$stringZ" : 'abc[A-Z]*.2'`     # 8
	  
3:index
  expr index $string $substring
       Numerical position in $string of first character 
	   in $substring that matches.
eg:
  stringZ=abcABC123ABCabc
  echo `expr index "$stringZ" C12`           # 6 
                                             # C position
  echo `expr index "$stringZ" 1c`            # 3
  # 'c' (in #3 position) matches before '1'.

4: Substring Extraction

##  0-based indexing.                                                    ## 
  ${string:position} 
   Extracts substring from $string at $position.
   If the $string parameter is "*" or "@", then this extracts 
   the positional parameters,starting at $position.

  ${string:position:length}
   Extracts $length characters of substring from $string at $position.

eg:
  # Is it possible to index from the right end of the string?
  stringZ=abcABC123ABCabc 
  echo ${stringZ:-4}                           # abcABC123ABCabc           ## ??
# Defaults to full string, as in ${parameter:-default}.
# However . . .
  echo ${stringZ:(-4)}                         # Cabc
  echo ${stringZ: -4}                          # Cabc
# Now, it works.
# Parentheses or added space "escape" the position parameter.               ## 


##  1-based indexing.                                                   ## 
 expr substr $string $position $length
   Extracts $length characters from $string starting at $position.

 expr match "$string" '\($substring\)'
 expr "$string" : '\($substring\)'
   Extracts $substring at beginning of $string

 expr match "$string" '.*\($substring\)'
 expr "$string" : '.*\($substring\)'
   Extracts $substring at end of $string

Substring Removal
  ${string#substring}
	Deletes shortest match of $substring from front of $string.
  ${string##substring}
	Deletes longest match of $substring from front of $string.
  ${string%substring}
    Deletes shortest match of $substring from back of $string.
  ${string%%substring}
    Deletes longest match of $substring from back of $string.

Substring Replacement
  ${string/substring/replacement}
    Replace first match of $substring with $replacement.
  ${string//substring/replacement}
    Replace all matches of $substring with $replacement.
  ${string/#substring/replacement}
    If $substring matches front end of $string, substitute $replacement for $substring.
    # must total match with front end
  ${string/%substring/replacement}
    If $substring matches back end of $string, substitute $replacement for $substring.
    # must total match with back end

Parameter Substitution
  ${parameter-default}, ${parameter:-default}
    If parameter not set, use default.
eg:
  echo ${username-`whoami`}
  # Echoes the result of `whoami`, if variable $username is still unset.


  ${parameter=default}, ${parameter:=default}
    If parameter not set, set it to default.
  ${parameter+alt_value}, ${parameter:+alt_value}
    If parameter set, use alt_value, else use null string.
  ${parameter?err_msg}, ${parameter:?err_msg}
    If parameter set, use it, else print err_msg.



















